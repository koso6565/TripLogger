package com.koso.triplogger.modelimport androidx.annotation.Keepimport androidx.room.Entityimport androidx.room.PrimaryKeyimport com.koso.powertry.constant.RecordingTopicimport com.koso.powertry.db.Examimport com.squareup.moshi.JsonClass@Keep@Entity(tableName = "triplogger_trip_table")@JsonClass(generateAdapter = true)data class Trip(    @PrimaryKey(autoGenerate = true)    var id: Long = 0,    val starttime: Long,    val endtime: Long,    val nodes: List<DataSet>,    val distance: Int,    val filename: String?,    var note: String,    //remote properties    var remoteid: String? = null,    var user: String? = null,    var reference: TripFileReference? = null)@Keep@JsonClass(generateAdapter = true)data class TripFileReference(    val bucket: String,    val path: String)fun Trip.findMaxSpeed(): Float{    var max = 0f    for (n in nodes) {        val speed = n.items[RecordingTopic.ManagedSpeed.tag].toString().toFloat()        if (speed > max) max = speed    }    return max}fun Trip.findFinalSpeed(exam: Exam): Float {    return when (exam.type) {        Exam.TYPE.acceleration.name, Exam.TYPE.decceleration.name -> {            return exam.getExamContent()!!.speedto!!        }        else -> {            var index = 0            for (i in nodes.indices) {                val distance =                    nodes[i].items[RecordingTopic.PowertryDistance.tag].toString()                        .toFloat()                if (distance > exam.getExamContent()!!.distance!!) {                    index = i                    break                }            }            val distance1 =                nodes[index - 1].items[RecordingTopic.PowertryDistance.tag].toString()                    .toFloat()            val distance2 =                nodes[index].items[RecordingTopic.PowertryDistance.tag].toString()                    .toFloat()            val speed1 =                nodes[index - 1].items[RecordingTopic.ManagedSpeed.tag].toString()                    .toFloat()            val speed2 =                nodes[index].items[RecordingTopic.ManagedSpeed.tag].toString().toFloat()            speed1 + ((exam.getExamContent()!!.distance!! - distance1) / (distance2 - distance1)) * (speed2 - speed1)        }    }}fun Trip.findElapsedTime(exam: Exam): Long {    return when (exam.type) {        Exam.TYPE.acceleration.name -> {            var index = 0            for (i in nodes.indices) {                val speed =                    nodes[i].items[RecordingTopic.ManagedSpeed.tag].toString().toFloat()                if (speed >= exam.getExamContent()!!.speedto!!) {                    index = i                    break                }            }            val t1 =                nodes[Math.max(                    index - 1,                    0                )].items[RecordingTopic.PowertryElapsedMilli.tag].toString()                    .toFloat()            val t2 = nodes[index].items[RecordingTopic.PowertryElapsedMilli.tag].toString()                .toFloat()            val speed1 =                nodes[Math.max(                    index - 1,                    0                )].items[RecordingTopic.ManagedSpeed.tag].toString()                    .toFloat()            val speed2 =                nodes[index].items[RecordingTopic.ManagedSpeed.tag].toString().toFloat()            (t1 + ((exam.getExamContent()!!.speedto!! - speed1) / (speed2 - speed1)) * (t2 - t1)).toLong()        }        Exam.TYPE.decceleration.name -> {            var index = 0            for (i in nodes.indices) {                val speed =                    nodes[i].items[RecordingTopic.ManagedSpeed.tag].toString().toFloat()                if (speed <= exam.getExamContent()!!.speedto!!) {                    index = i                    break                }            }            val t1 =                nodes[Math.max(                    index - 1,                    0                )].items[RecordingTopic.PowertryElapsedMilli.tag].toString()                    .toFloat()            val t2 = nodes[index].items[RecordingTopic.PowertryElapsedMilli.tag].toString()                .toFloat()            val speed1 =                nodes[Math.max(                    index - 1,                    0                )].items[RecordingTopic.ManagedSpeed.tag].toString()                    .toFloat()            val speed2 =                nodes[index].items[RecordingTopic.ManagedSpeed.tag].toString().toFloat()            (t1 + ((exam.getExamContent()!!.speedto!! - speed1) / (speed2 - speed1)) * (t2 - t1)).toLong()        }        else -> {            var index = 0            for (i in nodes.indices) {                val distance =                    nodes[i].items[RecordingTopic.PowertryDistance.tag].toString()                        .toFloat()                if (distance > exam.getExamContent()!!.distance!!) {                    index = i                    break                }            }            val t1 =                nodes[index - 1].items[RecordingTopic.PowertryElapsedMilli.tag].toString()                    .toFloat()            val t2 = nodes[index].items[RecordingTopic.PowertryElapsedMilli.tag].toString()                .toFloat()            val distance1 =                nodes[index - 1].items[RecordingTopic.PowertryDistance.tag].toString()                    .toFloat()            val distance2 =                nodes[index].items[RecordingTopic.PowertryDistance.tag].toString()                    .toFloat()            (t1 + ((exam.getExamContent()!!.distance!! - distance1) / (distance2 - distance1)) * (t2 - t1)).toLong()        }    }}fun Trip.findDistance(exam: Exam): Float {    return when (exam.type) {        Exam.TYPE.acceleration.name, Exam.TYPE.decceleration.name -> {            var index = 0            for (i in nodes.indices) {                val speed =                    nodes[i].items[RecordingTopic.ManagedSpeed.tag].toString().toFloat()                if ((exam.type == Exam.TYPE.acceleration.name && speed >= exam.getExamContent()!!.speedto!!) ||                    exam.type == Exam.TYPE.decceleration.name && speed <= exam.getExamContent()!!.speedto!!                ) {                    index = i                    break                }            }            if (index > 0) {                val distance1 =                    nodes[index - 1].items[RecordingTopic.PowertryDistance.tag].toString()                        .toFloat()                val distance2 =                    nodes[index].items[RecordingTopic.PowertryDistance.tag].toString()                        .toFloat()                val speed1 =                    nodes[index - 1].items[RecordingTopic.ManagedSpeed.tag].toString()                        .toFloat()                val speed2 =                    nodes[index].items[RecordingTopic.ManagedSpeed.tag].toString()                        .toFloat()                distance1 + ((exam.getExamContent()!!.speedto!! - speed1) / (speed2 - speed1)) * (distance2 - distance1)            } else {                0f            }        }        else -> {            exam.getExamContent()!!.distance!!        }    }}fun Trip.findStartFlag(exam: Exam): Long {    if (nodes.isEmpty()) return 0    return when (exam.type) {        Exam.TYPE.acceleration.name -> {            var index = 0            for (i in nodes.indices) {                val speed =                    nodes[i].items[RecordingTopic.ManagedSpeed.tag].toString().toFloat()                if (speed > exam.getExamContent()!!.speedfrom!!) {                    index = i                    break                }            }            if (index > 0) index -= 1            nodes[index].timestamp        }        Exam.TYPE.decceleration.name -> {            var index = 0            for (i in nodes.indices) {                val speed =                    nodes[i].items[RecordingTopic.ManagedSpeed.tag].toString().toFloat()                if (speed < exam.getExamContent()!!.speedfrom!!) {                    index = i                    break                }            }            if (index > 0) index -= 1            nodes[index].timestamp        }        else -> {            var index = 0            for (i in nodes.indices) {                val speed =                    nodes[i].items[RecordingTopic.ManagedSpeed.tag].toString().toFloat()                if (speed > 0) {                    index = i                    break                }            }            if (index > 0) index -= 1            nodes[index].timestamp        }    }}fun Trip.findEndFlag(exam: Exam): Long {    if (nodes.isEmpty()) return 0    return when (exam.type) {        Exam.TYPE.acceleration.name -> {            var index = 0            for (i in nodes.indices) {                val speed =                    nodes[i].items[RecordingTopic.ManagedSpeed.tag].toString().toFloat()                if (speed > exam.getExamContent()!!.speedto!!) {                    index = i                    break                }            }            nodes[index].timestamp        }        Exam.TYPE.decceleration.name -> {            var index = 0            for (i in nodes.indices) {                val speed =                    nodes[i].items[RecordingTopic.ManagedSpeed.tag].toString().toFloat()                if (speed <= exam.getExamContent()!!.speedto!!) {                    index = i                    break                }            }            nodes[index].timestamp        }        else -> {            var index = 0            for (i in nodes.indices) {                val distance =                    nodes[i].items[RecordingTopic.PowertryDistance.tag].toString()                        .toFloat()                if (distance > exam.getExamContent()!!.distance!!) {                    index = i                    break                }            }            nodes[index].timestamp        }    }}